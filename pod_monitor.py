"""
Generated by Cursor AI Assistant
https://cursor.sh

Pod monitoring module for collecting metrics from Kubernetes/OpenShift pods.
"""

import logging
import subprocess
import json
import re
from datetime import datetime
from typing import List, Dict, Optional
import time

logger = logging.getLogger(__name__)


class PodMonitor:
    """Monitors Kubernetes/OpenShift pods for status, CPU, and memory usage."""
    
    def __init__(self, namespace: str, pod_patterns: List[str], interval: int = 30):
        """
        Initialize the pod monitor.
        
        Args:
            namespace: Kubernetes namespace to monitor
            pod_patterns: List of pod name patterns (supports wildcards)
            interval: Monitoring interval in seconds
        """
        self.namespace = namespace
        self.pod_patterns = pod_patterns
        self.interval = interval
        self.metrics_history = []
        
    def get_matching_pods(self) -> List[str]:
        """
        Get list of pods matching the configured patterns.
        
        Returns:
            List of pod names
        """
        try:
            cmd = ["oc", "get", "pods", "-n", self.namespace, "-o", "json"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            pods_data = json.loads(result.stdout)
            
            matching_pods = []
            for pod in pods_data.get("items", []):
                pod_name = pod["metadata"]["name"]
                for pattern in self.pod_patterns:
                    # Convert wildcard pattern to regex
                    regex_pattern = pattern.replace("*", ".*")
                    if re.match(regex_pattern, pod_name):
                        matching_pods.append(pod_name)
                        break
            
            logger.debug(f"Found {len(matching_pods)} matching pods: {matching_pods}")
            return matching_pods
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to get pods: {e.stderr}")
            return []
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse pod list: {e}")
            return []
    
    def get_pod_status(self, pod_name: str) -> Dict[str, str]:
        """
        Get the status of a specific pod.
        
        Args:
            pod_name: Name of the pod
            
        Returns:
            Dictionary with pod status information
        """
        try:
            cmd = ["oc", "get", "pod", pod_name, "-n", self.namespace, "-o", "json"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            pod_data = json.loads(result.stdout)
            
            status = pod_data.get("status", {})
            phase = status.get("phase", "Unknown")
            
            # Get container statuses
            container_statuses = status.get("containerStatuses", [])
            ready_count = sum(1 for cs in container_statuses if cs.get("ready", False))
            total_count = len(container_statuses)
            
            return {
                "phase": phase,
                "ready": f"{ready_count}/{total_count}",
                "restarts": sum(cs.get("restartCount", 0) for cs in container_statuses),
                "age": self._calculate_pod_age(pod_data["metadata"].get("creationTimestamp"))
            }
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to get status for pod {pod_name}: {e.stderr}")
            return {"phase": "Error", "ready": "0/0", "restarts": 0, "age": "Unknown"}
        except (json.JSONDecodeError, KeyError) as e:
            logger.error(f"Failed to parse pod status for {pod_name}: {e}")
            return {"phase": "Error", "ready": "0/0", "restarts": 0, "age": "Unknown"}
    
    def get_pod_metrics(self, pod_name: str) -> Dict[str, Optional[str]]:
        """
        Get CPU and memory metrics for a specific pod.
        
        Args:
            pod_name: Name of the pod
            
        Returns:
            Dictionary with CPU and memory metrics
        """
        try:
            cmd = ["oc", "adm", "top", "pod", pod_name, "-n", self.namespace, "--no-headers"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            # Parse output: NAME CPU(cores) MEMORY(bytes)
            parts = result.stdout.strip().split()
            if len(parts) >= 3:
                return {
                    "cpu": parts[1],
                    "memory": parts[2]
                }
            else:
                return {"cpu": "N/A", "memory": "N/A"}
                
        except subprocess.CalledProcessError as e:
            logger.debug(f"Failed to get metrics for pod {pod_name}: {e.stderr}")
            return {"cpu": "N/A", "memory": "N/A"}
    
    def collect_metrics(self) -> List[Dict]:
        """
        Collect metrics for all matching pods.
        
        Returns:
            List of metric dictionaries
        """
        timestamp = datetime.now()
        pods = self.get_matching_pods()
        metrics = []
        
        for pod_name in pods:
            status = self.get_pod_status(pod_name)
            pod_metrics = self.get_pod_metrics(pod_name)
            
            metric_entry = {
                "timestamp": timestamp.isoformat(),
                "pod_name": pod_name,
                "phase": status["phase"],
                "ready": status["ready"],
                "restarts": status["restarts"],
                "cpu": pod_metrics["cpu"],
                "memory": pod_metrics["memory"]
            }
            
            metrics.append(metric_entry)
            logger.debug(f"Collected metrics for {pod_name}: {metric_entry}")
        
        self.metrics_history.extend(metrics)
        return metrics
    
    def get_metrics_history(self) -> List[Dict]:
        """
        Get the complete metrics history.
        
        Returns:
            List of all collected metrics
        """
        return self.metrics_history
    
    def _calculate_pod_age(self, creation_timestamp: str) -> str:
        """
        Calculate pod age from creation timestamp.
        
        Args:
            creation_timestamp: ISO format timestamp
            
        Returns:
            Human-readable age string
        """
        try:
            from dateutil import parser
            created = parser.parse(creation_timestamp)
            age = datetime.now(created.tzinfo) - created
            
            days = age.days
            hours = age.seconds // 3600
            minutes = (age.seconds % 3600) // 60
            
            if days > 0:
                return f"{days}d{hours}h"
            elif hours > 0:
                return f"{hours}h{minutes}m"
            else:
                return f"{minutes}m"
                
        except Exception as e:
            logger.debug(f"Failed to calculate pod age: {e}")
            return "Unknown"

