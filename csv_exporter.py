"""
Generated by Cursor AI Assistant
https://cursor.sh

CSV exporter and graph plotting module for test results and metrics.
"""

import logging
import os
import csv
from datetime import datetime
from typing import List, Dict
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots

logger = logging.getLogger(__name__)


class CSVExporter:
    """Exports metrics and results to CSV and generates graphs."""
    
    def __init__(self, results_dir: str, csv_filename: str, enable_graphs: bool = True, graph_format: str = "png"):
        """
        Initialize the CSV exporter.
        
        Args:
            results_dir: Directory to save results
            csv_filename: Base filename for CSV (timestamp will be added)
            enable_graphs: Whether to generate graphs
            graph_format: Graph output format (png, svg, pdf)
        """
        self.results_dir = results_dir
        self.csv_filename = csv_filename
        self.enable_graphs = enable_graphs
        self.graph_format = graph_format
        
        # Create results directory if it doesn't exist
        os.makedirs(results_dir, exist_ok=True)
        
        # Generate timestamped filenames
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.metrics_csv = os.path.join(results_dir, f"{csv_filename}_metrics_{timestamp}.csv")
        self.results_csv = os.path.join(results_dir, f"{csv_filename}_results_{timestamp}.csv")
        self.failed_tests_csv = os.path.join(results_dir, f"{csv_filename}_failed_tests_{timestamp}.csv")
        
    def export_metrics(self, metrics: List[Dict]) -> str:
        """
        Export pod metrics to CSV.
        
        Args:
            metrics: List of metric dictionaries
            
        Returns:
            Path to the created CSV file
        """
        if not metrics:
            logger.warning("No metrics to export")
            return ""
        
        try:
            # Define CSV headers
            headers = ["timestamp", "pod_name", "phase", "ready", "restarts", "cpu", "memory"]
            
            file_exists = os.path.exists(self.metrics_csv)
            
            with open(self.metrics_csv, 'a', newline='') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=headers)
                
                if not file_exists:
                    writer.writeheader()
                
                for metric in metrics:
                    writer.writerow({k: metric.get(k, "") for k in headers})
            
            logger.info(f"Exported {len(metrics)} metric entries to {self.metrics_csv}")
            return self.metrics_csv
            
        except Exception as e:
            logger.error(f"Failed to export metrics to CSV: {e}")
            return ""
    
    def export_test_results(self, results: List[Dict]) -> str:
        """
        Export test results to CSV.
        
        Args:
            results: List of test result dictionaries
            
        Returns:
            Path to the created CSV file
        """
        if not results:
            logger.warning("No test results to export")
            return ""
        
        try:
            # Define CSV headers
            headers = ["timestamp", "cr_name", "passed", "phase", "tests_passed", "tests_failed", "tests_skipped", "message"]
            
            file_exists = os.path.exists(self.results_csv)
            
            with open(self.results_csv, 'a', newline='') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=headers)
                
                if not file_exists:
                    writer.writeheader()
                
                for result in results:
                    writer.writerow({k: result.get(k, "") for k in headers})
            
            logger.info(f"Exported {len(results)} test results to {self.results_csv}")
            return self.results_csv
            
        except Exception as e:
            logger.error(f"Failed to export test results to CSV: {e}")
            return ""
    
    def export_failed_tests(self, failed_tests: List[Dict]) -> str:
        """
        Export failed test details to CSV.
        
        Args:
            failed_tests: List of failed test dictionaries
            
        Returns:
            Path to the created CSV file
        """
        if not failed_tests:
            logger.debug("No failed tests to export")
            return ""
        
        try:
            # Define CSV headers
            headers = ["timestamp", "cr_name", "pod_name", "test_number", "test_name", "duration"]
            
            file_exists = os.path.exists(self.failed_tests_csv)
            
            with open(self.failed_tests_csv, 'a', newline='') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=headers)
                
                if not file_exists:
                    writer.writeheader()
                
                for failed_test in failed_tests:
                    writer.writerow({k: failed_test.get(k, "") for k in headers})
            
            logger.info(f"Exported {len(failed_tests)} failed test entries to {self.failed_tests_csv}")
            return self.failed_tests_csv
            
        except Exception as e:
            logger.error(f"Failed to export failed tests to CSV: {e}")
            return ""
    
    def generate_graphs(self) -> List[str]:
        """
        Generate graphs from the exported CSV data.
        
        Returns:
            List of paths to generated graph files
        """
        if not self.enable_graphs:
            logger.info("Graph generation is disabled")
            return []
        
        graph_files = []
        
        # Generate pod metrics graphs
        if os.path.exists(self.metrics_csv):
            try:
                graph_file = self._generate_pod_metrics_graph()
                if graph_file:
                    graph_files.append(graph_file)
            except Exception as e:
                logger.error(f"Failed to generate pod metrics graph: {e}")
        
        # Generate test results graphs
        if os.path.exists(self.results_csv):
            try:
                graph_file = self._generate_test_results_graph()
                if graph_file:
                    graph_files.append(graph_file)
            except Exception as e:
                logger.error(f"Failed to generate test results graph: {e}")
        
        return graph_files
    
    def _generate_pod_metrics_graph(self) -> str:
        """Generate interactive graphs for pod metrics."""
        try:
            df = pd.read_csv(self.metrics_csv)
            
            if df.empty:
                logger.warning("No data to plot for pod metrics")
                return ""
            
            # Convert timestamp to datetime
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            # Parse CPU and memory values
            df['cpu_numeric'] = df['cpu'].apply(self._parse_cpu_value)
            df['memory_numeric'] = df['memory'].apply(self._parse_memory_value)
            
            # Create subplots
            fig = make_subplots(
                rows=3, cols=1,
                subplot_titles=('Pod CPU Usage (millicores)', 'Pod Memory Usage (Mi)', 'Pod Restarts'),
                vertical_spacing=0.1
            )
            
            # Plot data for each pod
            for pod_name in df['pod_name'].unique():
                pod_data = df[df['pod_name'] == pod_name]
                
                # CPU plot
                fig.add_trace(
                    go.Scatter(x=pod_data['timestamp'], y=pod_data['cpu_numeric'],
                              mode='lines+markers', name=f'{pod_name} CPU'),
                    row=1, col=1
                )
                
                # Memory plot
                fig.add_trace(
                    go.Scatter(x=pod_data['timestamp'], y=pod_data['memory_numeric'],
                              mode='lines+markers', name=f'{pod_name} Memory', showlegend=False),
                    row=2, col=1
                )
                
                # Restarts plot
                fig.add_trace(
                    go.Scatter(x=pod_data['timestamp'], y=pod_data['restarts'],
                              mode='lines+markers', name=f'{pod_name} Restarts', showlegend=False),
                    row=3, col=1
                )
            
            # Update layout
            fig.update_layout(
                height=900,
                title_text="Pod Metrics Over Time",
                showlegend=True,
                hovermode='x unified'
            )
            
            # Update axes
            fig.update_xaxes(title_text="Time", row=3, col=1)
            fig.update_yaxes(title_text="CPU (m)", row=1, col=1)
            fig.update_yaxes(title_text="Memory (Mi)", row=2, col=1)
            fig.update_yaxes(title_text="Count", row=3, col=1)
            
            # Save graph
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            graph_file = os.path.join(self.results_dir, f"pod_metrics_{timestamp}.html")
            fig.write_html(graph_file)
            
            # Also save as static image
            if self.graph_format in ['png', 'svg', 'pdf']:
                static_file = os.path.join(self.results_dir, f"pod_metrics_{timestamp}.{self.graph_format}")
                fig.write_image(static_file)
                logger.info(f"Generated static graph: {static_file}")
            
            logger.info(f"Generated pod metrics graph: {graph_file}")
            return graph_file
            
        except Exception as e:
            logger.error(f"Error generating pod metrics graph: {e}")
            return ""
    
    def _generate_test_results_graph(self) -> str:
        """Generate graphs for test results."""
        try:
            df = pd.read_csv(self.results_csv)
            
            if df.empty:
                logger.warning("No data to plot for test results")
                return ""
            
            # Convert timestamp to datetime
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            # Create figure with subplots
            fig = make_subplots(
                rows=2, cols=1,
                subplot_titles=('Test Pass/Fail Status', 'Test Counts'),
                vertical_spacing=0.15
            )
            
            # Pass/Fail timeline
            for cr_name in df['cr_name'].unique():
                cr_data = df[df['cr_name'] == cr_name]
                passed_numeric = cr_data['passed'].apply(lambda x: 1 if x else 0)
                
                fig.add_trace(
                    go.Scatter(x=cr_data['timestamp'], y=passed_numeric,
                              mode='markers', name=cr_name,
                              marker=dict(size=10)),
                    row=1, col=1
                )
            
            # Test counts stacked bar
            fig.add_trace(
                go.Bar(x=df['timestamp'], y=df['tests_passed'], name='Passed', marker_color='green'),
                row=2, col=1
            )
            fig.add_trace(
                go.Bar(x=df['timestamp'], y=df['tests_failed'], name='Failed', marker_color='red'),
                row=2, col=1
            )
            fig.add_trace(
                go.Bar(x=df['timestamp'], y=df['tests_skipped'], name='Skipped', marker_color='orange'),
                row=2, col=1
            )
            
            # Update layout
            fig.update_layout(
                height=700,
                title_text="Test Results Over Time",
                showlegend=True,
                barmode='stack'
            )
            
            # Update axes
            fig.update_xaxes(title_text="Time", row=2, col=1)
            fig.update_yaxes(title_text="Status (0=Fail, 1=Pass)", row=1, col=1)
            fig.update_yaxes(title_text="Test Count", row=2, col=1)
            
            # Save graph
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            graph_file = os.path.join(self.results_dir, f"test_results_{timestamp}.html")
            fig.write_html(graph_file)
            
            # Also save as static image
            if self.graph_format in ['png', 'svg', 'pdf']:
                static_file = os.path.join(self.results_dir, f"test_results_{timestamp}.{self.graph_format}")
                fig.write_image(static_file)
                logger.info(f"Generated static graph: {static_file}")
            
            logger.info(f"Generated test results graph: {graph_file}")
            return graph_file
            
        except Exception as e:
            logger.error(f"Error generating test results graph: {e}")
            return ""
    
    def _parse_cpu_value(self, cpu_str: str) -> float:
        """Parse CPU value from string (e.g., '100m' -> 100)."""
        try:
            if cpu_str == "N/A" or not cpu_str:
                return 0.0
            if cpu_str.endswith('m'):
                return float(cpu_str[:-1])
            return float(cpu_str) * 1000  # Convert cores to millicores
        except (ValueError, AttributeError):
            return 0.0
    
    def _parse_memory_value(self, mem_str: str) -> float:
        """Parse memory value from string (e.g., '128Mi' -> 128)."""
        try:
            if mem_str == "N/A" or not mem_str:
                return 0.0
            
            # Remove unit and convert to Mi
            if mem_str.endswith('Ki'):
                return float(mem_str[:-2]) / 1024
            elif mem_str.endswith('Mi'):
                return float(mem_str[:-2])
            elif mem_str.endswith('Gi'):
                return float(mem_str[:-2]) * 1024
            else:
                # Assume bytes
                return float(mem_str) / (1024 * 1024)
        except (ValueError, AttributeError):
            return 0.0

